<!doctype html>
<html class="no-js" lang="en" data-content_root="">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<meta property="og:title" content="Stiefel manifold" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://modula.systems/algorithms/manifold/stiefel/" />
<meta property="og:site_name" content="Modula" />
<meta property="og:description" content="ðŸ“š This page contains original research. To cite the Modula docs, hereâ€™s some BibTeX: On this page we shall consider a problem that I affectionately refer to as manifold Muon â€”or, more formally, the..." />
<meta property="og:image" content="https://docs.modula.systems/_static/logo-square.jpeg" />
<meta property="og:image:alt" content="Modula" />
<meta name="description" content="ðŸ“š This page contains original research. To cite the Modula docs, hereâ€™s some BibTeX: On this page we shall consider a problem that I affectionately refer to as manifold Muon â€”or, more formally, the..." />
<link rel="index" title="Index" href="../../../genindex/"><link rel="search" title="Search" href="../../../search/"><link rel="next" title="Hello, World!" href="../../../examples/hello-world/"><link rel="prev" title="Orthogonal manifold" href="../orthogonal/">
        <link rel="prefetch" href="../../../_static/logo-light.svg" as="image">
        <link rel="prefetch" href="../../../_static/logo-dark.svg" as="image">

    <link rel="shortcut icon" href="../../../_static/favicon.ico"><!-- Generated with Sphinx 7.0.0 and Furo 2025.12.19 -->
        <title>Stiefel manifold - docs.modula.systems</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=8bfd17e78cc47c62ac1c32270c918bcbddd8698e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.4cbf315f70debaebd550c87a6162cf0f.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=c2381d17322d81725993bfddb61bde80003e8cc4" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../"><div class="brand">docs.modula.systems</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../">
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo-light.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo-dark.svg" alt="Dark Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../../../search/" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Introduction:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/quickstart/">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/whats-in-a-norm/">Whatâ€™s in a norm?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/reading-list/">Reading list</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Algorithms:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../newton-schulz/">Newton-Schulz</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../">Manifold duality maps</a><input aria-label="Toggle navigation of Manifold duality maps" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../hypersphere/">Hypersphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../orthogonal/">Orthogonal manifold</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Stiefel manifold</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/hello-world/">Hello, World!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/hello-mnist/">Hello, MNIST!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/hello-gpt/">Hello, GPT!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/weight-erasure/">Weight erasure</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More on Modula:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/">Modula FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/modula-systems/modula">Modula codebase</a></li>
<li class="toctree-l1"><a class="reference external" href="https://modula.systems/">Modula homepage</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/modula-systems/modula/blob/main/docs/source/algorithms/manifold/stiefel.rst?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/modula-systems/modula/edit/main/docs/source/algorithms/manifold/stiefel.rst" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="stiefel-manifold">
<h1>Stiefel manifold<a class="headerlink" href="#stiefel-manifold" title="Permalink to this heading">Â¶</a></h1>
<p>ðŸ“š <em>This page contains original research. To cite the Modula docs, hereâ€™s some BibTeX:</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@misc</span><span class="p">{</span><span class="n">modula</span><span class="o">-</span><span class="n">docs</span><span class="p">,</span>
   <span class="n">author</span>  <span class="o">=</span> <span class="p">{</span><span class="n">Jeremy</span> <span class="n">Bernstein</span><span class="p">},</span>
   <span class="n">title</span>   <span class="o">=</span> <span class="p">{</span><span class="n">The</span> <span class="n">Modula</span> <span class="n">Docs</span><span class="p">},</span>
   <span class="n">url</span>     <span class="o">=</span> <span class="p">{</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">docs</span><span class="o">.</span><span class="n">modula</span><span class="o">.</span><span class="n">systems</span><span class="o">/</span><span class="p">},</span>
   <span class="n">year</span>    <span class="o">=</span> <span class="mi">2025</span>
<span class="p">}</span>
</pre></div>
</div>
<p>On this page we shall consider a problem that I affectionately refer to as <em>manifold Muon</em>â€”or, more formally, the problem of <em>steepest descent under the spectral norm on the Stiefel manifold</em>. This problem arises when one is interested in taking the best possible optimization step in a spectral norm geometry (useful for accelerating training) while keeping the size of the weight matrices tightly regulated (potentially helpful for training stability and removing learning rate confounders). This page will generalize the analysis from <a class="reference internal" href="../orthogonal/"><span class="doc">the square case</span></a> to the full Stiefel manifold.</p>
<p>I posed manifold Muon as an open problem on the <a class="reference external" href="https://docs.modula.systems/algorithms/manifold/orthogonal/#open-problem-extending-to-the-stiefel-manifold">Modula docs</a> earlier this year, and two researchers Franz Louis Cesista (a.k.a. Leloy) and Jianlin Su recently proposed solutions. Leloy proposed a <a class="reference external" href="https://leloykun.github.io/ponder/steepest-descent-stiefel/">heuristic solution</a> via alternating projections, and Jianlin <a class="reference external" href="https://kexue.fm/archives/11221">solved the problem</a> by setting up a fixed point iteration. I heard about Leloyâ€™s work and an early version of Jianlinâ€™s approach (which did not yet work) and managed to solve the problem myself with a slightly different approach based on Lagrangian duality, which I will present in the next section. I also want to acknowledge that <a class="reference external" href="https://scholar.google.com/citations?user=Vo3M-WIAAAAJ&amp;hl">CÃ©dric Simal</a> independently proposed studying the dual problem to me and Leloy, after I had worked out the following analysis.</p>
<section id="formulating-the-problem">
<h2>Formulating the problem<a class="headerlink" href="#formulating-the-problem" title="Permalink to this heading">Â¶</a></h2>
<p>Letâ€™s set up the problem mathematically. Say we have a matrix-valued optimization variable <span class="math notranslate nohighlight">\(W \in \mathbb{R}^{m \times n}\)</span> where, without loss of generality, we take <span class="math notranslate nohighlight">\(m\geq n\)</span> so that the matrix has more rows than columns. And we have a cost function <span class="math notranslate nohighlight">\(\mathcal{C}:\mathbb{R}^{m \times n}\to\mathbb{R}\)</span> that we would like to minimize. We would also like to constrain the matrix <span class="math notranslate nohighlight">\(W\)</span> to the following set:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathsf{Stiefel}(m,n) := \left\{ W \in \mathbb{R}^{m \times n} \mid W^T W = I_n \right\}.\]</div>
</div>
<p>This set is known as the <em>Stiefel manifold</em>. A matrix <span class="math notranslate nohighlight">\(W\in\mathsf{Stiefel}(m,n)\)</span> for <span class="math notranslate nohighlight">\(m&gt;n\)</span> is known as a <em>semi-orthogonal</em> matrixâ€”since it has too few columns to form a complete orthonormal basis. There are various alternative ways to characterize the Stiefel manifold. For example, it is equivalently defined as the set of <span class="math notranslate nohighlight">\(m \times n\)</span> matrices with unit <span class="math notranslate nohighlight">\(\ell_2 \to \ell_2\)</span> condition number. Suffice to say, the Stiefel manifold is a very well-behaved class of matrices.</p>
<p>We would like to be able to take optimization steps that lie tangent to this manifold. Just as in <a class="reference internal" href="../orthogonal/"><span class="doc">the square case</span></a>, we can show that the tangent space to the Stiefel manifold at semi-orthogonal matrix <span class="math notranslate nohighlight">\(W\in\mathsf{Stiefel}(m,n)\)</span> is given by the following linear subspace of the ambient matrix space <span class="math notranslate nohighlight">\(\mathbb{R}^{m \times n}\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathsf{T}_W \mathsf{Stiefel}(m,n) = \left\{ A \in \mathbb{R}^{m \times n} \mid A^\top W + W^\top A = 0 \right\}.\]</div>
</div>
<p>In the context of Riemannian optimization, there are <a class="reference external" href="https://press.princeton.edu/absil">established means</a> of projecting the gradient to this linear subspace in order to take steps tangent to the Stiefel manifold. But to make life more interesting, we shall be interested in cost functions with a different sort of structure. In particular, suppose our cost <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> is Lipschitz-smooth in the <em>spectral norm</em>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\mathcal{C}(W + \Delta W) \leq \mathcal{C}(W) + \langle \nabla \mathcal{C}(W), \Delta W\rangle + \tfrac{1}{2} \cdot \| \Delta W \|_{\mathrm{spectral}}^2,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\langle \nabla \mathcal{C}(W), \Delta W\rangle \equiv \operatorname{trace} \nabla \mathcal{C}^\top \Delta W\)</span> is the Frobenius inner product between the derivative of the cost and the weight update, measuring the first-order change in cost. To motivate this smoothness structure, observe that matrices in a neural network act as <em>operators</em> on vectors, and the spectral norm respects this factâ€”see our <a class="reference external" href="https://arxiv.org/abs/2409.20325">anthology</a> for more on this. Spectral norm smoothness suggests taking optimization steps of controlled spectral norm. And since the spectral norm does not emerge from an inner product, spectral norm smoothness takes us outside the realm of Riemannian geometry.</p>
<p>All told, we would like to design a gradient descent algorithm whose updates exploit the spectral norm geometry of the cost function while lying tangent to the Stiefel manifold. Here we focus on the problem of choosing the <em>direction</em> of the step given these constraints, and offload the problem of choosing the <em>magnitude</em> to the learning rate. We formulate the optimal update direction as the matrix <span class="math notranslate nohighlight">\(A\)</span> that solves the following minimization problem:</p>
<div class="math-wrapper docutils container" id="eq-primal">
<div class="math notranslate nohighlight" id="eq-primal">
\[\min_{A \in \mathbb{R}^{m \times n}} \underbrace{\mathstrut \operatorname{trace}(G^\top A)}_{\text{linearization of cost}} \quad \text{subject to} \quad \underbrace{\|A\|_{\mathrm{spectral}} \leq 1}_{\text{spectral constraint}} \quad \text{and} \quad \underbrace{\mathstrut A^\top W + W^\top A = 0}_{\text{tangent space constraint}}. \qquad (1)\]</div>
</div>
<p>In this expression, <span class="math notranslate nohighlight">\(W\)</span> is the current point on the manifold, <span class="math notranslate nohighlight">\(G := \nabla \mathcal{C}(W)\)</span> is shorthand for the derivative of the cost, and <span class="math notranslate nohighlight">\(A\)</span> is the update direction that we seek. In words, we want to find an update direction that squeezes out the most linear improvement in cost while lying inside the ball of unit spectral norm and also lying tangent to the Stiefel manifold.</p>
</section>
<section id="solving-manifold-muon-via-lagrangian-duality">
<h2>Solving manifold Muon via Lagrangian duality<a class="headerlink" href="#solving-manifold-muon-via-lagrangian-duality" title="Permalink to this heading">Â¶</a></h2>
<p>Similar to Jianlinâ€™s approach, we introduce a matrix <span class="math notranslate nohighlight">\(\Lambda\in\mathbb{R}^{n\times n}\)</span> of Lagrange multipliers, and define a Lagrangian function <span class="math notranslate nohighlight">\(\mathcal{L}(A, \Lambda)\)</span> that incorporates the tangent space constraint:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\mathcal{L}(A, \Lambda) &amp;:= \operatorname{trace} G^\top A + \operatorname{trace}\Lambda^\top (A^\top W + W^\top A) \\
&amp;= \operatorname{trace}A^\top (G + 2W(\Lambda+\Lambda^\top)),
\end{align*}\end{split}\]</div>
</div>
<p>where the second equality follows by applying the cyclic property of the trace and transposing one term. One can check that our original problem <a class="reference internal" href="#eq-primal"><span class="std std-ref">(1)</span></a> is equivalent to the saddle point problem <span class="math notranslate nohighlight">\(\min_{\|A\|_\mathrm{spectral} \leq 1} \max_{\Lambda} \mathcal{L}(A,\Lambda)\)</span> since for any <span class="math notranslate nohighlight">\(A\)</span> that violates the tangent space constraint, the inner maximization with respect to <span class="math notranslate nohighlight">\(\Lambda\)</span> would send the Lagrangian to infinity. By Sionâ€™s minimax theorem, we can swap the order of the <span class="math notranslate nohighlight">\(\min\)</span> and <span class="math notranslate nohighlight">\(\max\)</span> to obtain:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\min_{\|A\|_\mathrm{spectral} \leq 1} \max_{\Lambda} \mathcal{L}(A,\Lambda) = \max_{\Lambda} \min_{\|A\|_\mathrm{spectral} \leq 1}  \mathcal{L}(A,\Lambda).\]</div>
</div>
<p>Following <a class="reference external" href="https://jeremybernste.in/writing/deriving-muon">an argument</a> which is now standard in Muon lore, we recognize the optimal value <span class="math notranslate nohighlight">\(A_\mathrm{opt}(\Lambda)\)</span> of the primal variable <span class="math notranslate nohighlight">\(A\)</span> for a given dual variable <span class="math notranslate nohighlight">\(\Lambda\)</span> as:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A_{\mathrm{opt}}(\Lambda) := \mathop{\mathrm{arg\,min}}_{\|A\|_\mathrm{spectral} \leq 1}  \mathcal{L}(A,\Lambda) = - \operatorname{msign} (G+2W(\Lambda+\Lambda^\top)),\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\operatorname{msign}\)</span> is the <em>matrix sign function</em>, defined as the elementwise sign function applied to the singular values of a matrix, or in PyTorch code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="k">def</span> <span class="nf">msign</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">U</span> <span class="o">@</span> <span class="n">S</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span><span class="o">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">@</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>Note that <span class="math notranslate nohighlight">\(\operatorname{msign}\)</span> can be computed efficiently on GPUs without taking an SVD via <a class="reference external" href="https://arxiv.org/abs/2409.20325">Newton-Schulz iteration</a> as in the recent <a class="reference external" href="https://arxiv.org/abs/2505.16932">Polar Express</a> algorithm.</p>
<p>Substituting <span class="math notranslate nohighlight">\(A_\mathrm{opt}(\Lambda)\)</span> back into the Lagrangian, we uncover the dual problem:</p>
<div class="math-wrapper docutils container" id="eq-dual">
<div class="math notranslate nohighlight" id="eq-dual">
\[\max_{\Lambda}\mathcal{L}(A_\mathrm{opt}(\Lambda), \Lambda) = \max_{\Lambda} -\|G + W (\Lambda+\Lambda^\top)\|_\mathrm{nuclear}.\]</div>
</div>
<p>In contrast to the primal problem <a class="reference internal" href="#eq-primal"><span class="std std-ref">(1)</span></a>, the dual problem is completely unconstrained. We may solve the dual problem by running gradient ascent on the Lagrangian dual function <span class="math notranslate nohighlight">\(\mathcal{L}(A_\mathrm{opt}(\Lambda), \Lambda)\)</span>â€”a technique formally known as <em>dual ascent</em>. After some work, the gradient of the dual functionâ€”or, more precisely, a <em>subgradient</em>â€”is given by the following formula:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
H(\Lambda) &amp;:= - \nabla_\Lambda \|G + W (\Lambda+\Lambda^\top)\|_\mathrm{nuclear} \\
&amp;= - [W^\top\mathrm{msign}(G + 2W (\Lambda+\Lambda^\top)) + \operatorname{msign}(G + 2W (\Lambda+\Lambda^\top))^\top W].
\end{align*}\end{split}\]</div>
</div>
<p>To obtain this expression, we have applied the chain rule and the fact that <span class="math notranslate nohighlight">\(\operatorname{msign}(X)\)</span> is in the subdifferential of <span class="math notranslate nohighlight">\(\|X\|_\mathrm{nuclear}\)</span>.</p>
<p>This expression for <span class="math notranslate nohighlight">\(H(\Lambda)\)</span> also has an intuitive interpretation: it measures the deviation of the current setting of <span class="math notranslate nohighlight">\(A_\mathrm{opt}(\Lambda)\)</span> from satisfying the tangent space condition. <a class="reference external" href="https://kexue.fm/archives/11221">Jianlinâ€™s solution</a> can be interpreted as running a fixed point iteration on the first-order optimality condition for the dual problem: <span class="math notranslate nohighlight">\(H(\Lambda_\mathrm{opt}) = 0\)</span>. Instead of running this fixed point iteration, we propose a different approach known as <em>dual ascent</em>.</p>
</section>
<section id="the-dual-ascent-algorithm">
<h2>The dual ascent algorithm<a class="headerlink" href="#the-dual-ascent-algorithm" title="Permalink to this heading">Â¶</a></h2>
<p>In this section, we write down a gradient ascent algorithm to solve the Lagrangian dual problem. Given a tolerance <span class="math notranslate nohighlight">\(\mathtt{tol}&gt;0\)</span> and a step size <span class="math notranslate nohighlight">\(\alpha&gt;0\)</span> for updating the dual variable <span class="math notranslate nohighlight">\(\Lambda\)</span>, the algorithm is given by:</p>
<ol class="arabic simple">
<li><p>Initialize the dual variable: <span class="math notranslate nohighlight">\(\Lambda = -\tfrac{1}{4} \times (W^\top G + G^\top W)\)</span>.</p></li>
<li><p>Compute the candidate update direction: <span class="math notranslate nohighlight">\(A = - \operatorname{msign}(G + 2W \Lambda)\)</span>.</p></li>
<li><p>Measure the deviation of <span class="math notranslate nohighlight">\(A\)</span> from the tangent space: <span class="math notranslate nohighlight">\(H = W^\top A + A^\top W\)</span>.</p></li>
<li><p>Check the stopping criterion:</p>
<ol class="loweralpha simple">
<li><p>If the deviation is small enough, i.e. <span class="math notranslate nohighlight">\(\|H\|_\mathrm{F} / \sqrt{mn} &lt; \mathtt{tol}\)</span>, then return <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p>Otherwise, update the dual variable: <span class="math notranslate nohighlight">\(\Lambda \gets \Lambda + \alpha \times H\)</span> and go back to step 2.</p></li>
</ol>
</li>
</ol>
<p>Observe that the dual variable <span class="math notranslate nohighlight">\(\Lambda\)</span> remains symmetric throughout this procedure, so we can use <span class="math notranslate nohighlight">\(2 \Lambda\)</span> in place of <span class="math notranslate nohighlight">\(\Lambda + \Lambda^\top\)</span> at step 2. The motivation for the special initialization of <span class="math notranslate nohighlight">\(\Lambda\)</span> is that it leads to the algorithm terminating on the first step if <span class="math notranslate nohighlight">\(W\)</span> is square. This is because step 2 already recovers the optimal value of <span class="math notranslate nohighlight">\(A\)</span> <a class="reference internal" href="../orthogonal/"><span class="doc">for the square case</span></a> and so <span class="math notranslate nohighlight">\(H=0\)</span> at step 3. In actual neural network training, where <span class="math notranslate nohighlight">\(G\)</span> may not change much between steps because of momentum, it might make more sense to warm start <span class="math notranslate nohighlight">\(\Lambda\)</span> from the previous iteration.</p>
<p>Once this algorithm terminates, we take the returned value of the primal variable <span class="math notranslate nohighlight">\(A\)</span> and make the tangent space update <span class="math notranslate nohighlight">\(W \gets W + \eta \times A\)</span>. The final step is to retract the updated weights back to the manifold. We will work out a retraction map in the next section.</p>
</section>
<section id="working-out-the-retraction-map">
<h2>Working out the retraction map<a class="headerlink" href="#working-out-the-retraction-map" title="Permalink to this heading">Â¶</a></h2>
<p>An update in the tangent space will diverge slightly from the manifold for finite step sizes <span class="math notranslate nohighlight">\(\eta\)</span>. As such we need to find a retraction map to project the updated weights back to the manifold. It turns out that the retraction map can be implemented in a simple way, by introducing an extra matrix <span class="math notranslate nohighlight">\(C\)</span> to the update:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[W \gets (W + \eta \times A)\cdot C.\]</div>
</div>
<p>We just need to solve for the proper value of <span class="math notranslate nohighlight">\(C\)</span>. Checking the semi-orthogonality condition and using the fact that <span class="math notranslate nohighlight">\(W^\top A + A^\top W = 0\)</span> because the update direction <span class="math notranslate nohighlight">\(A\)</span> belongs to the tangent space, we find that:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
C^\top(W - \eta A)^\top (W - \eta A)C &amp;=C^\top [W^\top W - \eta \times [W^\top A + A^\top W] + \eta^2 A^\top A]C \\
&amp;= C^\top[I_n - A^\top A + (1+\eta^2) \cdot A^\top A]C.
\end{align*}\end{split}\]</div>
</div>
<p>Even though <span class="math notranslate nohighlight">\(A\)</span> is an output of <span class="math notranslate nohighlight">\(\operatorname{msign}\)</span>, it may not hold that <span class="math notranslate nohighlight">\(A^\top A = I_n\)</span> because <span class="math notranslate nohighlight">\(A\)</span> may be low rank. We need to find a matrix <span class="math notranslate nohighlight">\(C\)</span> satisfying <span class="math notranslate nohighlight">\(C^\top[I_n - A^\top A + (1+\eta^2) \cdot A^\top A]C = I_n\)</span>. This task is made substantially easier by observing that <span class="math notranslate nohighlight">\(A^\top A\)</span> and <span class="math notranslate nohighlight">\(I_n - A^\top A\)</span> are orthogonal projectors. We can then read off a suitable value for <span class="math notranslate nohighlight">\(C\)</span> as:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[C = C^\top = I_n - A^\top A + \frac{A^\top A}{\sqrt{1+\eta^2}}.\]</div>
</div>
<p>While it is nice to have an analytical expression for the retraction map, in practice it might be numerically advantageous just to use <span class="math notranslate nohighlight">\(\operatorname{msign}\)</span> to project the updated weights back to the manifold.</p>
</section>
<section id="pytorch-implementation">
<h2>PyTorch implementation<a class="headerlink" href="#pytorch-implementation" title="Permalink to this heading">Â¶</a></h2>
<p>Here we give a basic PyTorch implementation for solving manifold Muon via dual ascent. The code re-uses the <code class="docutils literal notranslate"><span class="pre">msign</span></code> function defined earlier in the post.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">manifold_muon</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
    <span class="c1"># Ensure that W and G are both tall matrices</span>
    <span class="n">should_tranpose</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">should_tranpose</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Initialize the dual variable</span>
    <span class="n">Lambda</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">G</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W</span><span class="p">)</span>
    <span class="c1"># Ascend on the dual problem to find the update direction A</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
        <span class="c1"># Update the candidate direction A</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">msign</span><span class="p">(</span><span class="n">G</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">W</span> <span class="o">@</span> <span class="n">Lambda</span><span class="p">)</span>
        <span class="c1"># Measure deviation of A from the tangent space:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">W</span>
        <span class="c1"># Check the stopping criterion</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">numel</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Update the dual variable</span>
        <span class="n">Lambda</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">step</span> <span class="o">/</span> <span class="n">steps</span><span class="p">)</span> <span class="o">*</span> <span class="n">H</span>
    <span class="c1"># Descend on the primal problem</span>
    <span class="n">new_W</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">A</span>
    <span class="c1"># Retract to the manifold</span>
    <span class="n">new_W</span> <span class="o">+=</span> <span class="n">new_W</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Restore the shape of the solution and return</span>
    <span class="k">return</span> <span class="n">new_W</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">should_tranpose</span> <span class="k">else</span> <span class="n">new_W</span>
</pre></div>
</div>
</section>
<section id="acknowledgments">
<h2>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this heading">Â¶</a></h2>
<p>I am grateful to <a class="reference external" href="https://leloykun.github.io/ponder/steepest-descent-stiefel/">Leloy</a> and <a class="reference external" href="https://kexue.fm/archives/11221/">Jianlin Su</a> for sharing their excellent work on this topic. I also want to acknowledge <a class="reference external" href="https://scholar.google.com/citations?user=Vo3M-WIAAAAJ&amp;hl">CÃ©dric Simal</a> who independently proposed studying the dual problem to me, after I had worked out this dual ascent approach. I am incredibly grateful to the team at <a class="reference external" href="https://thinkingmachines.ai/">Thinking Machines</a> for supporting me to explore this problem. Any mistakes in this writeup are my own responsibility.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../../../examples/hello-world/">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Hello, World!</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../orthogonal/">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Orthogonal manifold</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Jeremy Bernstein
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/modula-systems/modula" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Stiefel manifold</a><ul>
<li><a class="reference internal" href="#formulating-the-problem">Formulating the problem</a></li>
<li><a class="reference internal" href="#solving-manifold-muon-via-lagrangian-duality">Solving manifold Muon via Lagrangian duality</a></li>
<li><a class="reference internal" href="#the-dual-ascent-algorithm">The dual ascent algorithm</a></li>
<li><a class="reference internal" href="#working-out-the-retraction-map">Working out the retraction map</a></li>
<li><a class="reference internal" href="#pytorch-implementation">PyTorch implementation</a></li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/tabs.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>